'use client';

import { useMemo, useState, useCallback, useRef } from 'react';
import { Project } from '@/types/project';

interface SearchIndex {
  id: number;
  searchableText: string;
  normalizedName: string;
  normalizedCountry: string;
  normalizedTracks: string[];
  project: Project;
}

interface SearchOptions {
  debounceMs?: number;
  minQueryLength?: number;
  maxResults?: number;
  fuzzyThreshold?: number;
}

export function useOptimizedSearch(
  projects: Project[], 
  options: SearchOptions = {}
) {
  const {
    debounceMs = 150,
    minQueryLength = 2,
    maxResults = 1000,
    fuzzyThreshold = 0.6
  } = options;

  const [query, setQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const debounceRef = useRef<NodeJS.Timeout>();
  const cacheRef = useRef<Map<string, Project[]>>(new Map());

  // Pre-compute search index with normalized text
  const searchIndex = useMemo(() => {
    return projects.map((project): SearchIndex => {
      const searchableText = [
        project.name || '',
        project.description || '',
        project.country || '',
        ...(project.tracks || []),
        project.twitterHandle || ''
      ].join(' ').toLowerCase().trim();

      return {
        id: project.id,
        searchableText,
        normalizedName: (project.name || '').toLowerCase(),
        normalizedCountry: (project.country || '').toLowerCase(),
        normalizedTracks: (project.tracks || []).map(t => t.toLowerCase()),
        project
      };
    });
  }, [projects]);

  // Fast search with multiple strategies
  const performSearch = useCallback((searchQuery: string): Project[] => {
    if (!searchQuery || searchQuery.length < minQueryLength) {
      return projects;
    }

    // Check cache first
    const cacheKey = searchQuery.toLowerCase();
    if (cacheRef.current.has(cacheKey)) {
      return cacheRef.current.get(cacheKey)!;
    }

    const normalizedQuery = searchQuery.toLowerCase();
    const queryTerms = normalizedQuery.split(/\s+/).filter(Boolean);
    const results: Project[] = [];
    const scores = new Map<number, number>();

    for (const item of searchIndex) {
      let score = 0;
      let matchCount = 0;

      // Exact name match (highest priority)
      if (item.normalizedName.includes(normalizedQuery)) {
        score += 100;
        matchCount++;
      }

      // Country match
      if (item.normalizedCountry.includes(normalizedQuery)) {
        score += 50;
        matchCount++;
      }

      // Track matches
      for (const track of item.normalizedTracks) {
        if (track.includes(normalizedQuery)) {
          score += 30;
          matchCount++;
        }
      }

      // Multi-term search in searchable text
      for (const term of queryTerms) {
        if (item.searchableText.includes(term)) {
          score += 10;
          matchCount++;
        }
      }

      // Fuzzy matching for typos (simplified)
      if (matchCount === 0 && queryTerms.length === 1) {
        const term = queryTerms[0];
        if (term.length > 3) {
          // Simple fuzzy: check if most characters match
          const fuzzyScore = calculateFuzzyScore(term, item.searchableText);
          if (fuzzyScore > fuzzyThreshold) {
            score += fuzzyScore * 5;
            matchCount++;
          }
        }
      }

      if (matchCount > 0) {
        scores.set(item.id, score);
        results.push(item.project);
      }
    }

    // Sort by relevance score
    results.sort((a, b) => (scores.get(b.id) || 0) - (scores.get(a.id) || 0));

    // Limit results and cache
    const limitedResults = results.slice(0, maxResults);
    cacheRef.current.set(cacheKey, limitedResults);

    // Prevent cache from growing too large
    if (cacheRef.current.size > 100) {
      const firstKey = cacheRef.current.keys().next().value;
      cacheRef.current.delete(firstKey);
    }

    return limitedResults;
  }, [searchIndex, projects, minQueryLength, maxResults, fuzzyThreshold]);

  // Optimized debounced search
  const search = useCallback((newQuery: string) => {
    setQuery(newQuery);
    
    if (debounceRef.current) {
      clearTimeout(debounceRef.current);
    }

    // Immediate search for short queries or clearing
    if (newQuery.length === 0 || newQuery.length < minQueryLength) {
      setIsSearching(false);
      return;
    }

    setIsSearching(true);

    // Adaptive debouncing - shorter delay for longer queries
    const adaptiveDelay = Math.max(50, debounceMs - (newQuery.length * 10));

    debounceRef.current = setTimeout(() => {
      setIsSearching(false);
    }, adaptiveDelay);
  }, [debounceMs, minQueryLength]);

  const filteredProjects = useMemo(() => {
    return performSearch(query);
  }, [query, performSearch]);

  // Clear cache when projects change
  useMemo(() => {
    cacheRef.current.clear();
  }, [projects]);

  return {
    query,
    search,
    filteredProjects,
    isSearching,
    resultCount: filteredProjects.length,
    clearSearch: () => search('')
  };
}

// Simple fuzzy matching helper
function calculateFuzzyScore(term: string, text: string): number {
  let matches = 0;
  let termIndex = 0;
  
  for (let i = 0; i < text.length && termIndex < term.length; i++) {
    if (text[i] === term[termIndex]) {
      matches++;
      termIndex++;
    }
  }
  
  return matches / term.length;
} 